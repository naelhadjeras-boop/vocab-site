<!doctype html>
if(l.includes(',')) out.push(...l.split(',').map(s=>s.trim()))
else if(l.includes(';')) out.push(...l.split(';').map(s=>s.trim()))
else {
// if short, treat as word; if long, try splitting by spaces but keep multiword expressions
if(l.split(' ').length<=3) out.push(l)
else out.push(...l.split(/,|;|\||\//).map(s=>s.trim()))
}
if(out.length>=100) break
}
return out.slice(0,100).filter(Boolean)
}


async function generate(){
const text = phrase.value.trim();
const key = apikey.value.trim();
const opt = options.value.trim();
if(!text){ alert('Merci d\'entrer une phrase.'); phrase.focus(); return }
if(!key){ if(!confirm('Aucune clé fournie — voulez-vous continuer sans appeler l\'API (mode démo) ?')) return }


setLoading(true)
showWords([])


// Construct a strict prompt asking for JSON to simplify parsing
const system = `Tu es un assistant qui fournis des listes de vocabulaire. Réponds uniquement au format JSON strict, sans texte additionnel, et avec une propriété "words" qui contient exactement jusqu'à 100 mots ou expressions (liste). Exemple: {"words": ["mot1","mot2", ...]}. Pas d'explication.`
const userPrompt = `Phrase: "${text}"\nOptions: ${opt || 'aucune'}\nTâche: fournis jusqu'à 100 mots de vocabulaire pertinents, variés (noms, verbes, adjectifs, expressions courtes) liés au sujet. Réponds en JSON comme demandé.`


try{
let aiText = ''
if(key){
const resp = await fetch('https://api.openai.com/v1/chat/completions', {
method:'POST',
headers:{'Content-Type':'application/json','Authorization':'Bearer '+key},
body: JSON.stringify({
model: 'gpt-4o-mini', // utilisateur peut changer
messages: [
{role:'system', content: system},
{role:'user', content: userPrompt}
],
temperature:0.7,
max_tokens:800
})
})
if(!resp.ok){
const errText = await resp.text();
throw new Error('Erreur API: '+resp.status+' '+errText)
}
const data = await resp.json()
// la réponse peut être dans choices[0].message.content
aiText = data.choices?.[0]?.message?.content || ''
} else {
// Mode démo: on génère localement quelques mots (exemple réduit)
aiText = JSON.stringify({words:[
"exemple","démo","climat","changement","réchauffement","gaz à effet de serre","élévation","niveau de la mer","tempêtes","sécheresse","érosion","biodiversité","agriculture","adaptation","atténuation","subsistance","météo","prévision","émissions","carbone","forêts","océans","cycle","pollution","santé","économie","migration","risque","résilience","politique","énergie","durabilité","ressources","habitat","écosystème","conservation","inondation","canicule","glaciers","érosion","désertification","urbanisation","transport","industrie","stockage","captage","réduction","neutralité","objectif","protocole","traité","accord","sensibilisation","éducation","innovation","technologie","finance","investissement","subvention","taxe","régulation","norme","comportement","consommation","production","recyclage","reforestation","restauration","monitoring","satellite","mesure","indicateur","scénario","projection","modélisation","incertitude","rapport","scientifique","donnée","analyse","expert","gouvernance","communauté","partenariat","initiative","planification","urgence","alerte","capacité","formation","volontariat","participation","justice","équité","santé publique","prévention","réponse"]})
}


const words = parseResponseText(aiText)
showWords(words)
}catch(err){
console.error(err)
state.textContent = 'Erreur: '+err.message
alert('Erreur: '+err.message)
}finally{ setLoading(false) }
}


btn.addEventListener('click', generate)
clearBtn.addEventListener('click', ()=>{ phrase.value=''; options.value=''; showWords([]); state.textContent='Aucun résultat pour l\'instant.' })


copyBtn.addEventListener('click', ()=>{
const words = Array.from(list.querySelectorAll('.chip')).map(n=>n.textContent)
if(words.length===0){ alert('Rien à copier.'); return }
navigator.clipboard.writeText(words.join(', ')).then(()=>alert('Copié dans le presse-papier.'))
})


dlBtn.addEventListener('click', ()=>{
const words = Array.from(list.querySelectorAll('.chip')).map(n=>n.textContent)
if(words.length===0){ alert('Rien à télécharger.'); return }
const blob = new Blob([words.join('\n')], {type:'text/plain;charset=utf-8'})
const url = URL.createObjectURL(blob)
const a = document.createElement('a'); a.href=url; a.download='vocabulaire.txt'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url)
})


</script>
</body>
</html>